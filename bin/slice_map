#! /usr/bin/env jruby -J-Djava.awt.headless=true

include Java
require 'fileutils'

# JIF = java.io.File
# IIO = javax.imageio.ImageIO
# BI = java.awt.image.BufferedImage
# RENDERING_HINTS = java.awt.RenderingHints
DEFAULT_BI_TYPE = java.awt.image.BufferedImage::TYPE_INT_ARGB

TILE_SIZE = 256
SOURCE_IMAGE = File.join( File.dirname(__FILE__), "../var/maps/b.1.png" )
DEST_DIR = File.join( File.dirname(__FILE__) , "../var/tiles/b/1" )


def create_buffered_image( width, height, type = DEFAULT_BI_TYPE )
  return java.awt.image.BufferedImage.new( width, height, type )
end

def load_image( filename )
  file = java.io.File.new( filename )
  return javax.imageio.ImageIO.read(file)
end

def save_image( filename, image )
  javax.imageio.ImageIO.write( image, "PNG", java.io.File.new(filename) )
end

def crop( original, *rectangle )
  rectangle = rectangle[0] if rectangle[0].kind_of? Array
  cropped = create_buffered_image(rectangle[2],rectangle[3], DEFAULT_BI_TYPE )
  g = cropped.createGraphics
  g.translate( -rectangle[0], -rectangle[1] )
  g.drawImage( original, 0, 0, nil )
  return cropped
end


# Load image
source_image = load_image( SOURCE_IMAGE )
source_image_width, source_image_height = source_image.getWidth, source_image.getHeight

# clear destination directory
FileUtils.rm_r( Dir.glob(DEST_DIR + '/*') )

# Iterate over the source image, cutting out and saving tiles
(0..((source_image_height/TILE_SIZE)-1)).each do |y|
    (0..((source_image_width/TILE_SIZE)-1)).each do |x|
        tile = crop( source_image, x*TILE_SIZE, y*TILE_SIZE, TILE_SIZE, TILE_SIZE )
        save_image( File.join( DEST_DIR, "#{x}-#{y}.png"), tile )
    end
end