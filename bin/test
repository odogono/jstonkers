#!/usr/bin/env node

// unit test runner
// takes as an argument: 
//  a directory path - will process all test files within and below
//  a unit test name - only this file will be executed

var path = require("path"),
    fs = require('fs'),
    http = require('http');

var dirRoot = path.join( path.dirname(__filename), '../' );
var args = process.argv.slice(2);
var initial_directory = path.join( dirRoot, './test' );
var initial_file = null;

var common = require( path.join( dirRoot, './app/common') );

// to include common
// require.paths.push( path.join(dirRoot, 'lib') );
// var jstonkers = require('jstonkers');

// console.log("jstonkers: " + JSON.stringify(jstonkers));
// var v2f = jstonkers.utils.Vector2f.create( [9,-10] );
// console.log("RESULT " + dir_vendor );

// require.paths.push( path.join(dirRoot, 'vendor/nodeunit/lib') );
var testrunner = require('nodeunit').reporters.default;

/**
 * Assert response from `server` with
 * the given `req` object and `res` assertions object.
 * 'borrowed' from expresso
 *
 * @param {Server} server
 * @param {Object} req
 * @param {Object|Function} res
 * @param {String} msg
 */

assert.response = function(test, server, req, res, msg){
    var port = server.config.server.port;
    server.__port = server.config.server.port;
    
    // // Check that the server is ready or defer
    // if (!server.fd) {
    //     if (!('__deferred' in server)) {
    //         server.__deferred = [];
    //     }
    //     server.__deferred.push(arguments);
    //     if (!server.__started) {
    //         server.listen(server.__port = server.config.server.port++, '127.0.0.1', function(){
    //             if (server.__deferred) {
    //                 process.nextTick(function(){
    //                     server.__deferred.forEach(function(args){
    //                       assert.response.apply(assert, args);
    //                     });
    //                 });
    //             }
    //         });
    //         server.__started = true;
    //     }
    //     return;
    // }
    
    // Callback as third or fourth arg
    var callback = typeof res === 'function'
        ? res
        : typeof msg === 'function'
            ? msg
            : function(){};

    // Default message to test title
    if (typeof msg === 'function') msg = null;
    msg = msg || assert.testTitle;
    msg += '. ';
    
    // Pending responses
    server.__pending = server.__pending || 0;
    server.__pending++;

    // Create client
    if (!server.fd) {
        server.listen(server.__port = server.config.server.port++, '127.0.0.1', issue);
    } else {
        issue();
    }
    
    function issue(){
        // if (!server.client){
        //     log(inspect(server));
        //     log('creating client on port ' + server.__port );
        //     server.client = http.createClient(server.__port);
        // }

        // Issue request
        var timer,
            client = server.client,
            method = req.method || 'GET',
            status = res.status || res.statusCode,
            data = req.data || req.body,
            requestTimeout = req.timeout || 0;

        log('starting request with ' + method + ' serverport ' + (server.__port) + ' url ' + req.url + " headers " + req.headers );
        // var request = client.request(method, req.url, req.headers);
        var request = http.request({method:method, port:(server.__port), path:req.url, headers:req.headers});
        
        // Timeout
        if (requestTimeout) {
            timer = setTimeout(function(){
                --server.__pending || server.close();
                delete req.timeout;
                test.fail(msg + 'Request timed out after ' + requestTimeout + 'ms.');
            }, requestTimeout);
        }

        if (data){
            request.write(data);
        }
        request.on('error', function(response){
           log('got error ' + inspect(response) ); 
        });
        request.on('response', function(response){
            response.body = '';
            response.setEncoding('utf8');
            response.on('data', function(chunk){ 
                response.body += chunk; 
            });
            response.on('end', function(){
                --server.__pending || server.close();
                if (timer) clearTimeout(timer);

                // Assert response body
                if (res.body !== undefined) {
                    if( _.isFunction(res.body) ){
                        res.body( response.body );
                    }
                    else{
                        var eql = res.body instanceof RegExp
                          ? res.body.test(response.body)
                          : res.body === response.body;
                        // log( 'eql turns out to be ' + eql + ' ' + res.body );
                        test.ok(
                            eql,
                            msg + 'Invalid response body.\n'
                                + '    Expected: ' + inspect(res.body) + '\n'
                                + '    Got: ' + inspect(response.body)
                        );
                    }
                }

                // Assert response status
                if (typeof status === 'number') {
                    test.equal(
                        response.statusCode,
                        status,
                        msg + 'Invalid response status code.\n'
                            + '    Expected: {' + status + '}\n'
                            + '    Got: {' + response.statusCode + '}'
                    );
                }

                // Assert response headers
                if (res.headers) {
                    var keys = Object.keys(res.headers);
                    for (var i = 0, len = keys.length; i < len; ++i) {
                        var name = keys[i],
                            actual = response.headers[name.toLowerCase()],
                            expected = res.headers[name],
                            eql = expected instanceof RegExp
                              ? expected.test(actual)
                              : expected == actual;
                        test.ok(
                            eql,
                            msg + 'Invalid response header [bold]{' + name + '}.\n'
                                + '    Expected: {' + expected + '}\n'
                                + '    Got: {' + actual + '}'
                        );
                    }
                }

                // Callback
                callback(response);
            });
        });
        request.end();
      }
};

log( "cwd " + process.cwd() );
log( "dirname " + __dirname );
log( "dirRoot " + dirRoot );
log( "initial dir " + initial_directory );

// determine whether the first argument is a directory - if it is, then
// begin scanning for test files from there
if( args[0] )
{
    initial_file = args[0];
    var dir = path.join( dirRoot, args[0] );

    if( path.existsSync(dir) && fs.statSync(dir).isDirectory() )
    {
        initial_directory = dir;
        initial_file = null;
        log("start directory changed to " + dir );
    }
}

// recursively scans directories for potential test files
function scan_directory( dir, result ) {
    return fs.readdirSync(dir).reduce(function(a,filename){
        var fullpath = path.join( dir, filename );
        var stat = fs.statSync(fullpath);
    
        if( stat.isFile() ) {
            // if( initial_file && filename.indexOf(initial_file) === 0 )
            //    initial_file = fullpath;
            if( initial_file && filename.indexOf(initial_file) > -1 )
                initial_file = fullpath;
            if( /^test_.*\.js$/.exec(filename) )
                return a.concat( fullpath );
        }
        if( stat.isDirectory() )
            return a.concat( scan_directory( fullpath ) );
        return a;
    }, []);
}

// compile a list of test files
var files = scan_directory( initial_directory, [] );

if( path.existsSync(initial_file) )
    files = [ initial_file ];

// remove current working dir from each path
files = files.map(function (f) {
    if( f.indexOf(process.cwd()) > -1 )
        return f.substring( process.cwd().length );
    return f;
});


log("initial file: " + initial_file + " : " + path.existsSync(initial_file) );
log( "files: " + files );

testrunner.run( files );
